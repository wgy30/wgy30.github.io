[{"title":"线性表的链式存储之单链表(完整)","date":"2020-08-17T11:37:06.000Z","path":"2020/08/17/线性表的链式存储之单链表-完整/","text":"本文从零开始讲述单链表的基本操作。从开始的存储结构定义到实现一个具体的单链表，各种基本操作都通过具体的程序实现。欢迎指正！ 1. 声明结构&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在单链表的存储结构中，我们需要指定两个区域：数据域 data =和指针域 next ;故名思义，数据域，即存放数据的地方，指针域，即存放指向下一节点的地址的地方。因此我们定义的存储结构如下： 2. 初始化&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初始化，顾名思义就是在内存中开辟一块初始空间，存储数据域和指针域地址。在初始化中，单链表有两种方式：不带头结点和带头结点；由于在基本操作过程中，不带头结点的比带头结点的复杂，因此本文中的所有基本操作都是基于带头结点。同时，在链表中，我们要了解三个基本概念：头指针、头结点、首结点；对于基本概念，在此不再叙述，不懂的同学可以翻看数据结构课本复习一下，加深概念，建议借助图示加以理解。 第一种初始化方式（不带头结点）：&nbsp; 第二种初始化方式（带头结点）:3. 创建表&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;链表中的创建操作跟顺序存储中的有点不一样。可以通过两种方式：头插法和尾插法。 头插法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原理：从空表开始，生成一个新结点，每次插入时，都是从链表的表头开始插入。每个结点插入的复杂度为O(1),总复杂度为O(n).读入的数据与生成的链表的元素的顺序时相反的。因此，通过头插法建立的单链表是逆序的，打印时会逆序输出。&nbsp; 尾插法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原理：跟头插法相反，尾插法是插入新结点时，从表尾开始插入，因此要定义一个表尾指针，指示插入位置。由于尾插法每次都插入表尾中，也要遍历到表尾插入，因此复杂度为O(1)。尾插法读入的数据与生成的链表的元素顺序是相同的。4. 插入操作由于链式存储方式中存储地址不是连续的，只是由每个结点中的指针域的指向相连，因此在进行插入时，我们需要找到头指针，利用头指针指向遍历，找寻插入位置执行插入。在插入中有两种方式，一种是结点后插(insertNextNode)；另一种是结点前插(insertPriorNode)。两种方式各有优势。结点后插的复杂度为O(n),结点前插的复杂度为O(1)。 首先我们不进行封装优化，直接操作：&nbsp; 优化后，将部分流程封装，对外提供访问,这样便于我们进行优化处理。其中，return 返回的部分演示使用的是后插方式 insertNextNode，也可使用前插方式insertPriorNode，getELem()为获取插入结点的前一个结点：&nbsp;后插封装：&nbsp;前插封装： 4. 删除操作&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;删除操作跟插入操作类似，但又不相同。在删除查找中，当我们将某一结点删除 之后，要通过 free 函数释放该结点内存，这是一个良好的编程习惯。同时，由于在链表中，结点间是通过指针域的指向相连，因此删除某一结点的复杂度为O(1),但在删除时，需要找到其结点位置，因此也要遍历，所以总复杂度为O(n).在此之中，我们也可以将其中一些处理逻辑进行封装处理，由于在插入操作中已展示一些封装过程，在此不再过多讲述，就直接处理了。 删除处理逻辑： 5. 按位查找&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按位查找：顾名思义就是通过给定一个位置，返回其结点为位置。原理：设定一个计数器 j ,计算其位置。再通过头指针遍历，找到该结点，并将其返回。 处理逻辑 6. 按值查找&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按值查找：给定一个值，返回其结点。原理：与按位查找不同，在按值查找中，没有计数器。可以直接通过头指针遍历和访问遍历结点的数据域 data ,判断是否符合查找中 e 。 处理逻辑 7. 打印表&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在之前的顺序存储过程中，打印表的操作设定了的是什么时候的表，在此不再过多的讲述这些，要是对打印过程又不理解的同学，可返回看前边的顺序存储文章。因为打印操作就是通过头指针遍历结点，输入其数据域的数据。 8. 结语&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在此次单链表的实现中，我们把一些基本操作都实现了一遍，通过具体的逻辑处理，能够加深对链式存储的优势的理解，通过让我们对链式存储结构有一个基本的认识：不依赖连续的地址进行存储，对插入删除等操作有了明显的提升，不用移动大量元素便可实现。下一阶段，我们继续对链式存储 进行探究，如循环链表、双链表等。欢迎大家指教。","comments":true,"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://github.com/wgy30/wgy30.github.io/tree/master/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"c++","slug":"c","permalink":"https://github.com/wgy30/wgy30.github.io/tree/master/tags/c/"}]},{"title":"线性表的顺序存储——动态分配方式(完整)","date":"2020-08-09T11:07:21.000Z","path":"2020/08/09/线性表的顺序存储——动态分配方式-完整/","text":"本文是关于线性表的顺序存储的第二篇，这里把线性表的基本操作都实现以便，程序完整罗列出来了，若有不足之处，请多指教。 1. 动态分配结构&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;动态分配与静态分配的区别是：静态分配采用的是数组存储数据，大小需要提前设定，不可扩容，即在内存空间中开辟一块固有空间进行存储；动态采用的是 malloc(sizeo(ElemType)*INIT_SIZE) 来进行内存空间的分配,但超出 MAX_SIZE 时，通过再次分配进行扩容。因此，当储存过多数据时，建议使用动态分配方式。 2. 初始化&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初始化：就是给 data 分配一块内存空间，便于存储，代码如下： 3. 创建表&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在初始化完成之后，在内存空间中就有了一块空间提供个线性表，但是里边没有数据，就相当于一个空表，因此，我们需要通过创建一个表，保证后面的基本操作可以进行。参数 length，表示初始表的长度，参数 L[ ]，表示表中的原始数据。 4. 插入操作&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来的这些基本操作中，大都跟第一篇文章的相似，就不在这过多阐述了，直接把程序逻辑给出来了。要是有不理解的朋友，可以回去看下第一篇文章：线性表的顺序存储——静态分配方式实现 5. 删除操作 6. 按值查找 7. 按位查找 8. 打印表 9. 结语&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;至此，我们的线性表中的顺序存储方式的两种实现方式我们已经搞定了，接下来我们将继续线性表的链式存储以及其他数据结构的学习。","comments":true,"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://github.com/wgy30/wgy30.github.io/tree/master/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"c++","slug":"c","permalink":"https://github.com/wgy30/wgy30.github.io/tree/master/tags/c/"}]},{"title":"Github Page + hexo 搭建博客系列第一弹","date":"2020-08-07T10:07:10.000Z","path":"2020/08/07/Github-Page-hexo-搭建博客系列第一弹/","text":"本文从零开始讲述如何搭建一个自己的博客，如何利用Github Page白嫖一个美观、简约的“网站”。 1. 成果展示&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;话不多说,以图为证！&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;) 2. 初识Github Page&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一，首先我们需要申请一个github账号，然后创建一个”用户名.github.io“的仓库，注意：这个仓库名称必须严格按照方式命名。否则别人不能访问你的github Page页面。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二，我们需要将github跟我们本地连接起来，方便写文章后上传。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说明：由于GitHub作为一个很有名的代码托管平台，这里就不谈论贴步骤了。 3. 安装hexo和Node.js&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于hexo是基于node的静态博客，所以还是把node也安装吧。本地安装 hexo，使用 npm 方式安装。（建议：node版本建议使用高于6.2以上版本，后面更换hexo注意需要） 1node下载：https:&#x2F;&#x2F;nodejs.org&#x2F;dist&#x2F; 1node版本：node -v 1hexo安装： npm install -g hexo 1hexo版本：hexo v &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;安装结束后，我们需要初始化一个存放hexo的本地文件夹 1初始化：hexo init 文件内容及含义： 12345678· node_modules：是依赖包· public：存放的是生成的页面· scaffolds：命令生成文章等的模板· source：用命令创建的各种文章· themes：主题· _config.yml：整个博客的配置· db.json：source解析所得到的· package.json：项目所需模块项目的配置信息 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在完成了前面这些之后，我们就可以本地部署预览博客：http:localhost:4000。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;相关操作命令： 1hexo new &quot;文章标题&quot;：生成md文件 1hexo clean：清除已编译的静态文件 1hexo g：根据生成静态文件 1hexo s：启动hexo服务 1hexo d：提交远程仓库（后面用到） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;效果展示： 4. 结尾&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到此为止，我们已经利用了 GitHub Page 和 hexo 搭建了一个简单的博客主页，是不是很简单呢。接下来我们将讲解一些博客的简单配置，如语言，生成文章等以及更换主题。 ※ ※ ※ &nbsp;欢迎访问我的博客：北 野","comments":true,"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://github.com/wgy30/wgy30.github.io/tree/master/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"线性表的顺序存储——静态分配方式实现(完整)","date":"2020-08-07T07:10:25.000Z","path":"2020/08/07/线性表的顺序存储——静态分配方式实现-完整/","text":"说明：实现采用 C++ 实现，所列目录均已完全实现。在实现过程中，使用到了引用符号 &amp; ，通过对表的引用进行操作以及数组传参的知识。 本次操作是考研复习数据结构的一次复习，若有不足之处，欢迎指正。 1. 初始化说明：通过对线性表结构的初始化实现一个数据结构。同时，对结构里的空间赋值为0，避免产生脏数据。 2. 创建线性表说明：将数据作为参数进行传递，实现数据入表。因为初始建表时，未知表长。因此将一并将表长length作为参数传递。 3. 插入操作说明：i，为插入位置，e，为插入值。通过循环找到 i 的位置，将 e 插入，同时，i之后的所有数都要往后移，且length+1。 4. 删除操作说明：将参数 i 作为删除位置传递，并通过e返回删除值.然后 i 之后的值都往前移，且length-1。 5. 按值查找说明：通过输入的 e 的值作为参数，进入表中查找该数是否存在。若是，返回其位置下标，若不是，返回 -1 。 6. 按位查找说明：将 i 的输入作为查找位置，再用 e 返回其位置相对应的数。否则返回 -1 。 7. 打印线性表说明：设置一个 flag 标志，通过该标志判断当前表的状态，并将其打印出来。 8. 主函数操作说明：主函数中很大一部分封装在不同方法中使用，由于时间原因，暂时就这样吧（代码有点长了，可阅读性不太好）。","comments":true,"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://github.com/wgy30/wgy30.github.io/tree/master/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"c++","slug":"c","permalink":"https://github.com/wgy30/wgy30.github.io/tree/master/tags/c/"}]}]